//! Auxiliary helpers for working with autogenerated thrift structs.

#[allow(dead_code)]
mod sample;

use std::time::{Duration, SystemTime};

use thrift::protocol::{TFieldIdentifier, TInputProtocol, TType};

pub use self::sample::*;

impl StackSample {
    // Constructor to only initialize the required fields.
    //
    // This allows the rest of the code to remain backwards compatible
    // through schema changes.
    pub fn with_required(time: Timestamp) -> Self {
        let mut protocol = WrappedTimestampProtocol::new(time);
        StackSample::read_from_in_protocol(&mut protocol)
            .expect("timestamp protocol was not deserializable from timestamp as expected")
    }
}

impl From<SystemTime> for Timestamp {
    fn from(time: SystemTime) -> Self {
        let duration = time
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap_or(Duration::default());
        Timestamp::new(duration.as_secs() as _, duration.subsec_nanos() as _)
    }
}

// The code below is a work-around to backwards-compatibly create a StackSample
// instance even when the optional fields within are updated. The problem is
// this: the thrift rust doesn't generate a way to create a struct with required
// fields without also passing all the optional fields. We would like to avoid
// having to change the code the instant that someone adds an optional field to
// one of the structs that we are using.
//
// The solution I am using here is to define a dummy TInputProtocol that is
// hardcoded to emit the required field (timestamp) and nothing else. Since
// field ID numbers are part of the contract this is enough to create a struct
// instance with all the optional fields set to None. In addition, I have added
// a test case to ensure that this keeps working as expected. It will fail if a
// new required field is added to the protocol in which case these methods here
// would need to be updated anyway.

#[derive(Copy, Clone, PartialEq, Eq, Debug)]
enum State {
    Start,
    EmitTimestamp,
    EmitSecs,
    EmitNanos,
    Done,
}

struct WrappedTimestampProtocol {
    state: State,
    time: Timestamp,
}

impl WrappedTimestampProtocol {
    fn new(time: Timestamp) -> Self {
        Self {
            state: State::Start,
            time,
        }
    }
}

impl TInputProtocol for WrappedTimestampProtocol {
    fn read_struct_begin(&mut self) -> thrift::Result<Option<thrift::protocol::TStructIdentifier>> {
        match self.state {
            State::Start => self.state = State::EmitTimestamp,
            State::EmitTimestamp => self.state = State::EmitSecs,
            State::EmitSecs | State::EmitNanos => (),
            State::Done => unreachable!(),
        }

        Ok(None)
    }

    fn read_struct_end(&mut self) -> thrift::Result<()> {
        assert!(self.state == State::Done);

        Ok(())
    }

    fn read_field_begin(&mut self) -> thrift::Result<thrift::protocol::TFieldIdentifier> {
        match self.state {
            State::Start => unreachable!(),
            State::EmitTimestamp => Ok(TFieldIdentifier::new("timestamp", TType::Struct, 4)),
            State::EmitSecs => Ok(TFieldIdentifier::new("seconds", TType::I64, 1)),
            State::EmitNanos => Ok(TFieldIdentifier::new("nanoseconds", TType::I64, 2)),
            State::Done => Ok(TFieldIdentifier {
                name: None,
                field_type: TType::Stop,
                id: None,
            }),
        }
    }

    fn read_field_end(&mut self) -> thrift::Result<()> {
        match self.state {
            State::Start | State::EmitTimestamp => unreachable!(),
            State::EmitSecs => self.state = State::EmitNanos,
            State::EmitNanos => self.state = State::Done,
            State::Done => (),
        }

        Ok(())
    }

    fn read_i64(&mut self) -> thrift::Result<i64> {
        match self.state {
            State::Start | State::EmitTimestamp | State::Done => unimplemented!(),
            State::EmitSecs => Ok(self.time.seconds),
            State::EmitNanos => Ok(self.time.nanoseconds),
        }
    }

    fn read_message_begin(&mut self) -> thrift::Result<thrift::protocol::TMessageIdentifier> {
        unimplemented!()
    }

    fn read_message_end(&mut self) -> thrift::Result<()> {
        unimplemented!()
    }

    fn read_bool(&mut self) -> thrift::Result<bool> {
        unimplemented!()
    }

    fn read_bytes(&mut self) -> thrift::Result<Vec<u8>> {
        unimplemented!()
    }

    fn read_i8(&mut self) -> thrift::Result<i8> {
        unimplemented!()
    }

    fn read_i16(&mut self) -> thrift::Result<i16> {
        unimplemented!()
    }

    fn read_i32(&mut self) -> thrift::Result<i32> {
        unimplemented!()
    }

    fn read_double(&mut self) -> thrift::Result<f64> {
        unimplemented!()
    }

    fn read_string(&mut self) -> thrift::Result<String> {
        unimplemented!()
    }

    fn read_list_begin(&mut self) -> thrift::Result<thrift::protocol::TListIdentifier> {
        unimplemented!()
    }

    fn read_list_end(&mut self) -> thrift::Result<()> {
        unimplemented!()
    }

    fn read_set_begin(&mut self) -> thrift::Result<thrift::protocol::TSetIdentifier> {
        unimplemented!()
    }

    fn read_set_end(&mut self) -> thrift::Result<()> {
        unimplemented!()
    }

    fn read_map_begin(&mut self) -> thrift::Result<thrift::protocol::TMapIdentifier> {
        unimplemented!()
    }

    fn read_map_end(&mut self) -> thrift::Result<()> {
        unimplemented!()
    }

    fn read_byte(&mut self) -> thrift::Result<u8> {
        unimplemented!()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn building_stacksample_works() {
        let sample = StackSample::with_required(Timestamp::new(1, 2));

        assert_eq!(sample.time.seconds, 1);
        assert_eq!(sample.time.nanoseconds, 2);
    }
}
